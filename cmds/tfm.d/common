#!/bin/bash

# desc: verify & sync tf code common to all root modules

source $CLAMITY_ROOT/lib/_.sh || exit 1

function common_usage {
	_echo "usage: clamity tfm common { report | update | new-root <state-group> <module-name> }"
}

# return 0 if files are in sync
function check_all_common_files_in_module {
	local rootModuleDir="$1" action="$2"

	pushd "$rootModuleDir" >/dev/null
	[ `ls common-*.tf 2>/dev/null|wc -l` -eq 0 ] && popd >/dev/null && return 0  # no common files present
	local commonDir="$(cd ../../common && pwd)"
	local file fileToCopy=""

	for file in common-*.tf; do
		[ ! -f "$commonDir/$file" ] && echo "    $commonDir/$file not found (remove 'common-' from this file name)" && continue
		[ `diff $file "$commonDir/$file" | wc -l` -eq 0 ] && echo "    $file ok" && continue
		echo "    $file differs" && filesToCopy="$filesToCopy $file"
	done

	for file in "$commonDir"/common-*.tf; do [ ! -f "`basename $file`" ] && echo "    $(basename $file) not present"; done

	[ -z "$action" ] && popd >/dev/null && { [ -z "$filesToCopy" ] && return 0 || return 1; }
	for file in $filesToCopy; do
		echo "    updating $file"
		cp "$commonDir/$file" . || return 1
	done
	popd >/dev/null
	return 0
}

function iterate_through_common_files {
	local action="$1"
	local state_group root_mod rc=0
	# echo "TFM_REPO_ROOT=$TFM_REPO_ROOT"
	for state_group in $(cd "$TFM_REPO_ROOT/state-groups" && ls); do
		[ ! -d "$TFM_REPO_ROOT/state-groups/$state_group" -o $state_group == common ] && continue
		echo -e "\nState Group: $state_group"
		for root_mod in $(cd "$TFM_REPO_ROOT/state-groups/$state_group" && ls); do
			[ ! -d "$TFM_REPO_ROOT/state-groups/$state_group/$root_mod" ] && continue
			echo -e "\n  Root Module: $root_mod"
			check_all_common_files_in_module "$TFM_REPO_ROOT/state-groups/$state_group/$root_mod" $action || rc=1
		done
	done
	return $rc
}

function new_state_group {
	local stateDir="$1"
	_ask "Setup new state group `basename $stateDir` (y/N)? " || return 1
	_run mkdir $stateDir || return 1
}

function new_root_module {
	local state="$1" mod="$2"
	[ -z "$mod" ] && _echo "usage: clamity tfm common new-root <state> <mod>" && return 1
	local stateDir="$TFM_REPO_ROOT/state-groups/$state"
	local rootModDir="$stateDir/$mod"
	[ -d "$rootModDir" ] && _warn "$rootModDir exists" && return 1
	[ ! -d "$stateDir" ] && { new_state_group "$stateDir" || return 1; }
	_run mkdir "$rootModDir" || return 1
	_run cp "$TFM_REPO_ROOT"/state-groups/common/common-*.tf "$rootModDir" || return 1

	local cloudProvider=aws # FIXME: this should not be hard coded

	echo "
# This file is unique for each terraform root module. The key is a path prefix
# applied to the S3 bucket state object. It provides for maintaining multiple
# states on the same backend bucket without the need for workspaces.

terraform {
  backend \"s3\" {
    key = \"$state/$mod\"
  }
}" >$rootModDir/backend.tf || return 1

	echo "# $mod root module

* [Module document](https://github.com/PKT5/infra-as-code/blob/$state/modules/$mod/$cloudProvider/README.md)
* [State Listing](STATE.md)
* [Output Data](OUTPUT.json)
" >$rootModDir/README.md || return 1

	echo "
output \"props\" {
  value = module.$mod.props
}" >$rootModDir/output.tf

	echo "
variable \"custom_tags\" {
  type = map(string)
  default = {
    TerraformRoot = \"$state/$mod\"
  }
}

variable \"debug\" {
  type    = bool
  default = false
}
" >$rootModDir/variables.tf

	echo "
module \"$mod\" {
  source = \"../../../infra-as-code/modules/$mod/$cloudProvider\"
  providers = {
  }

  debug = var.debug
}
" >$rootModDir/main.tf
}

[ -z "$1" ] && common_usage && exit 1
subcmd="$1" && shift

case "$subcmd" in
	report)
		 iterate_through_common_files || exit 1;;
	update)
		[ ! -f ../../common/common-providers.tf ] && _warn "you must run this command from within a root module directory" && exit 1
		iterate_through_common_files update || exit 1;;
	new-root)
		new_root_module "$@" || exit 1;;
	*)
		common_usage && exit 1;;
esac
exit 0
